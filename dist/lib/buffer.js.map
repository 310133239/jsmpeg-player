{"version":3,"sources":["../../src/lib/buffer.js"],"names":["BitBuffer","bufferOrLength","mode","bytes","Uint8Array","byteLength","length","MODE","EXPAND","index","prototype","resize","size","newBytes","Math","min","set","evict","sizeNeeded","bytePos","available","copyWithin","subarray","write","buffers","isArrayOfBuffers","totalLength","i","newSize","max","appendSingleBuffer","buffer","findNextStartCode","findStartCode","code","current","nextBytesAreStartCode","peek","count","offset","value","currentByte","remaining","read","shift","mask","skip","rewind","has","EVICT"],"mappings":"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","file":"buffer.js","sourcesContent":["let BitBuffer = function(bufferOrLength, mode) {\r\n\tif (typeof(bufferOrLength) === 'object') {\r\n\t\tthis.bytes = (bufferOrLength instanceof Uint8Array)\r\n\t\t\t? bufferOrLength \r\n\t\t\t: new Uint8Array(bufferOrLength);\r\n\r\n\t\tthis.byteLength = this.bytes.length;\r\n\t}\r\n\telse {\r\n\t\tthis.bytes = new Uint8Array(bufferOrLength || 1024*1024);\t\r\n\t\tthis.byteLength = 0;\r\n\t}\r\n\r\n\tthis.mode = mode || BitBuffer.MODE.EXPAND;\r\n\tthis.index = 0;\r\n};\r\n\r\nBitBuffer.prototype.resize = function(size) {\r\n\tvar newBytes = new Uint8Array(size);\r\n\tif (this.byteLength !== 0) {\r\n\t\tthis.byteLength = Math.min(this.byteLength, size);\r\n\t\tnewBytes.set(this.bytes, 0, this.byteLength);\r\n\t}\r\n\tthis.bytes = newBytes;\r\n\tthis.index = Math.min(this.index, this.byteLength << 3);\r\n};\r\n\r\nBitBuffer.prototype.evict = function(sizeNeeded) {\r\n\tvar bytePos = this.index >> 3,\r\n\t\tavailable = this.bytes.length - this.byteLength;\r\n\t\r\n\t// If the current index is the write position, we can simply reset both\r\n\t// to 0. Also reset (and throw away yet unread data) if we won't be able\r\n\t// to fit the new data in even after a normal eviction.\r\n\tif (\r\n\t\tthis.index === this.byteLength << 3 ||\r\n\t\tsizeNeeded > available + bytePos // emergency evac\r\n\t) {\r\n\t\tthis.byteLength = 0;\r\n\t\tthis.index = 0;\r\n\t\treturn;\r\n\t}\r\n\telse if (bytePos === 0) {\r\n\t\t// Nothing read yet - we can't evict anything\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// Some browsers don't support copyWithin() yet - we may have to do \r\n\t// it manually using set and a subarray\r\n\tif (this.bytes.copyWithin) {\r\n\t\tthis.bytes.copyWithin(0, bytePos, this.byteLength);\r\n\t}\r\n\telse {\r\n\t\tthis.bytes.set(this.bytes.subarray(bytePos, this.byteLength));\r\n\t}\r\n\r\n\tthis.byteLength = this.byteLength - bytePos;\r\n\tthis.index -= bytePos << 3;\r\n\treturn;\r\n};\r\n\r\nBitBuffer.prototype.write = function(buffers) {\r\n\tvar isArrayOfBuffers = (typeof(buffers[0]) === 'object'),\r\n\t\ttotalLength = 0,\r\n\t\tavailable = this.bytes.length - this.byteLength;\r\n\r\n\t// Calculate total byte length\r\n\tif (isArrayOfBuffers) {\r\n\t\tvar totalLength = 0;\r\n\t\tfor (var i = 0; i < buffers.length; i++) {\r\n\t\t\ttotalLength += buffers[i].byteLength;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\ttotalLength = buffers.byteLength;\r\n\t}\r\n\r\n\t// Do we need to resize or evict?\r\n\tif (totalLength > available) {\r\n\t\tif (this.mode === BitBuffer.MODE.EXPAND) {\r\n\t\t\tvar newSize = Math.max(\r\n\t\t\t\tthis.bytes.length * 2,\r\n\t\t\t\ttotalLength - available\r\n\t\t\t);\r\n\t\t\tthis.resize(newSize)\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.evict(totalLength);\r\n\t\t}\r\n\t}\r\n\r\n\tif (isArrayOfBuffers) {\r\n\t\tfor (var i = 0; i < buffers.length; i++) {\r\n\t\t\tthis.appendSingleBuffer(buffers[i]);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tthis.appendSingleBuffer(buffers);\r\n\t}\r\n};\r\n\r\nBitBuffer.prototype.appendSingleBuffer = function(buffer) {\r\n\tbuffer = buffer instanceof Uint8Array\r\n\t\t? buffer \r\n\t\t: new Uint8Array(buffer);\r\n\t\r\n\tthis.bytes.set(buffer, this.byteLength);\r\n\tthis.byteLength += buffer.length;\r\n};\r\n\r\nBitBuffer.prototype.findNextStartCode = function() {\t\r\n\tfor (var i = (this.index+7 >> 3); i < this.byteLength; i++) {\r\n\t\tif(\r\n\t\t\tthis.bytes[i] == 0x00 &&\r\n\t\t\tthis.bytes[i+1] == 0x00 &&\r\n\t\t\tthis.bytes[i+2] == 0x01\r\n\t\t) {\r\n\t\t\tthis.index = (i+4) << 3;\r\n\t\t\treturn this.bytes[i+3];\r\n\t\t}\r\n\t}\r\n\tthis.index = (this.byteLength << 3);\r\n\treturn -1;\r\n};\r\n\r\nBitBuffer.prototype.findStartCode = function(code) {\r\n\tvar current = 0;\r\n\twhile (true) {\r\n\t\tcurrent = this.findNextStartCode();\r\n\t\tif (current === code || current === -1) {\r\n\t\t\treturn current;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n};\r\n\r\nBitBuffer.prototype.nextBytesAreStartCode = function() {\r\n\tvar i = (this.index+7 >> 3);\r\n\treturn (\r\n\t\ti >= this.byteLength || (\r\n\t\t\tthis.bytes[i] == 0x00 && \r\n\t\t\tthis.bytes[i+1] == 0x00 &&\r\n\t\t\tthis.bytes[i+2] == 0x01\r\n\t\t)\r\n\t);\r\n};\r\n\r\nBitBuffer.prototype.peek = function(count) {\r\n\tvar offset = this.index;\r\n\tvar value = 0;\r\n\twhile (count) {\r\n\t\tvar currentByte = this.bytes[offset >> 3],\r\n\t\t\tremaining = 8 - (offset & 7), // remaining bits in byte\r\n\t\t\tread = remaining < count ? remaining : count, // bits in this run\r\n\t\t\tshift = remaining - read,\r\n\t\t\tmask = (0xff >> (8-read));\r\n\r\n\t\tvalue = (value << read) | ((currentByte & (mask << shift)) >> shift);\r\n\r\n\t\toffset += read;\r\n\t\tcount -= read;\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\nBitBuffer.prototype.read = function(count) {\r\n\tvar value = this.peek(count);\r\n\tthis.index += count;\r\n\treturn value;\r\n};\r\n\r\nBitBuffer.prototype.skip = function(count) {\r\n\treturn (this.index += count);\r\n};\r\n\r\nBitBuffer.prototype.rewind = function(count) {\r\n\tthis.index = Math.max(this.index - count, 0);\r\n};\r\n\r\nBitBuffer.prototype.has = function(count) {\r\n\treturn ((this.byteLength << 3) - this.index) >= count;\r\n};\r\n\r\nBitBuffer.MODE = {\r\n\tEVICT: 1,\r\n\tEXPAND: 2\r\n};\r\n\r\nexport default BitBuffer;\r\n\r\n\r\n"]}