{"version":3,"sources":["../../src/lib/jsmpeg.js"],"names":["Player","VideoElement","BitBuffer","AjaxSource","AjaxProgressiveSource","WSSource","TS","BaseDecoder","MPEG1","MP2","WebGLRenderer","CanvasRenderer","WebAudioOut","JSMpeg","Source","Ajax","AjaxProgressive","WebSocket","Demuxer","Decoder","Base","MPEG1Video","MP2Audio","Renderer","WebGL","Canvas2D","AudioOutput","WebAudio","Now","window","performance","now","Date","Fill","array","value","fill","i","length"],"mappings":"AAAA;;AAEA;;AAEA,OAAOA,MAAP,MAAmB,UAAnB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,SAAP,MAAsB,UAAtB;AACA,OAAOC,UAAP,MAAuB,QAAvB;AACA,OAAOC,qBAAP,MAAkC,oBAAlC;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,EAAP,MAAe,MAAf;AACA,OAAOC,WAAP,MAAwB,WAAxB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,aAAP,MAA0B,SAA1B;AACA,OAAOC,cAAP,MAA2B,YAA3B;AACA,OAAOC,WAAP,MAAwB,YAAxB;;AAGA;AACA;AACA,IAAIC,SAAS;;AAEX;AACA;AACA;AACA;AACAb,UAAQA,MANG;;AAQX;AACA;AACA;AACAC,gBAAcA,YAXH;;AAaX;AACA;AACA;AACAC,aAAWA,SAhBA;;AAkBX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAY,UAAQ;AACNC,UAAMZ,UADA;AAENa,qBAAiBZ,qBAFX;AAGNa,eAAWZ;AAHL,GA3BG;;AAiCX;AACA;AACA;AACA;AACA;AACA;AACAa,WAAS;AACPZ,QAAIA;AADG,GAvCE;;AA2CX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAa,WAAS;AACPC,UAAMb,WADC;AAEPc,gBAAYb,KAFL;AAGPc,cAAUb;AAHH,GAtDE;;AA4DX;AACA;AACA;AACA;AACA;AACA;AACAc,YAAU;AACRC,WAAOd,aADC;AAERe,cAAUd;AAFF,GAlEC;;AAuEX;AACA;AACA;AACA;AACA;AACA;AACA;AACAe,eAAa;AACXC,cAAUf;AADC,GA9EF;;AAkFXgB,OAAK,eAAY;AACf,WAAOC,OAAOC,WAAP,GACHD,OAAOC,WAAP,CAAmBC,GAAnB,KAA2B,IADxB,GAEHC,KAAKD,GAAL,KAAa,IAFjB;AAGD,GAtFU;;AAwFX;AACA;AACA;AACA;AACA;AACA;;AAEAE,QAAM,cAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AAC5B,QAAID,MAAME,IAAV,EAAgB;AACdF,YAAME,IAAN,CAAWD,KAAX;AACD,KAFD,MAGK;AACH,WAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIH,MAAMI,MAA1B,EAAkCD,GAAlC,EAAuC;AACrCH,cAAMG,CAAN,IAAWF,KAAX;AACD;AACF;AACF;AAxGU,CAAb;;AA2GA,eAAetB,MAAf","file":"jsmpeg.js","sourcesContent":["/* According to jsmpeg project(https://github.com/phoboslab/jsmpeg) modified */\r\n\r\n// ES6 modular\r\n\r\nimport Player from './player';\r\nimport VideoElement from './video-element'\r\nimport BitBuffer from './buffer';\r\nimport AjaxSource from './ajax';\r\nimport AjaxProgressiveSource from './ajax-progressive';\r\nimport WSSource from './websocket';\r\nimport TS from './ts';\r\nimport BaseDecoder from './decoder';\r\nimport MPEG1 from './mpeg1';\r\nimport MP2 from './mp2';\r\nimport WebGLRenderer from './webgl';\r\nimport CanvasRenderer from './canvas2d';\r\nimport WebAudioOut from './webaudio';\r\n\r\n\r\n// This sets up the JSMpeg \"Namespace\". The object is empty apart from the Now()\r\n// utility function and the automatic CreateVideoElements() after DOMReady.\r\nlet JSMpeg = {\r\n\r\n  // The Player sets up the connections between source, demuxer, decoders,\r\n  // renderer and audio output. It ties everything together, is responsible\r\n  // of scheduling decoding and provides some convenience methods for\r\n  // external users.\r\n  Player: Player,\r\n\r\n  // A Video Element wraps the Player, shows HTML controls to start/pause\r\n  // the video and handles Audio unlocking on iOS. VideoElements can be\r\n  // created directly in HTML using the <div class=\"jsmpeg\"/> tag.\r\n  VideoElement: VideoElement,\r\n\r\n  // The BitBuffer wraps a Uint8Array and allows reading an arbitrary number\r\n  // of bits at a time. On writing, the BitBuffer either expands its\r\n  // internal buffer (for static files) or deletes old data (for streaming).\r\n  BitBuffer: BitBuffer,\r\n\r\n  // A Source provides raw data from HTTP, a WebSocket connection or any\r\n  // other mean. Sources must support the following API:\r\n  //   .connect(destinationNode)\r\n  //   .write(buffer)\r\n  //   .start() - start reading\r\n  //   .resume(headroom) - continue reading; headroom to play pos in seconds\r\n  //   .established - boolean, true after connection is established\r\n  //   .completed - boolean, true if the source is completely loaded\r\n  //   .progress - float 0-1\r\n  Source: {\r\n    Ajax: AjaxSource,\r\n    AjaxProgressive: AjaxProgressiveSource,\r\n    WebSocket: WSSource,\r\n  },\r\n\r\n  // A Demuxer may sit between a Source and a Decoder. It separates the\r\n  // incoming raw data into Video, Audio and other Streams. API:\r\n  //   .connect(streamId, destinationNode)\r\n  //   .write(buffer)\r\n  //   .currentTime â€“ float, in seconds\r\n  //   .startTime - float, in seconds\r\n  Demuxer: {\r\n    TS: TS,\r\n  },\r\n\r\n  // A Decoder accepts an incoming Stream of raw Audio or Video data, buffers\r\n  // it and upon `.decode()` decodes a single frame of data. Video decoders\r\n  // call `destinationNode.render(Y, Cr, CB)` with the decoded pixel data;\r\n  // Audio decoders call `destinationNode.play(left, right)` with the decoded\r\n  // PCM data. API:\r\n  //   .connect(destinationNode)\r\n  //   .write(pts, buffer)\r\n  //   .decode()\r\n  //   .seek(time)\r\n  //   .currentTime - float, in seconds\r\n  //   .startTime - float, in seconds\r\n  Decoder: {\r\n    Base: BaseDecoder,\r\n    MPEG1Video: MPEG1,\r\n    MP2Audio: MP2,\r\n  },\r\n\r\n  // A Renderer accepts raw YCrCb data in 3 separate buffers via the render()\r\n  // method. Renderers typically convert the data into the RGBA color space\r\n  // and draw it on a Canvas, but other output - such as writing PNGs - would\r\n  // be conceivable. API:\r\n  //   .render(y, cr, cb) - pixel data as Uint8Arrays\r\n  //   .enabled - wether the renderer does anything upon receiving data\r\n  Renderer: {\r\n    WebGL: WebGLRenderer,\r\n    Canvas2D: CanvasRenderer,\r\n  },\r\n\r\n  // Audio Outputs accept raw Stero PCM data in 2 separate buffers via the\r\n  // play() method. Outputs typically play the audio on the user's device.\r\n  // API:\r\n  //   .play(sampleRate, left, right) - rate in herz; PCM data as Uint8Arrays\r\n  //   .stop()\r\n  //   .enqueuedTime - float, in seconds\r\n  //   .enabled - wether the output does anything upon receiving data\r\n  AudioOutput: {\r\n    WebAudio: WebAudioOut,\r\n  },\r\n\r\n  Now: function () {\r\n    return window.performance\r\n      ? window.performance.now() / 1000\r\n      : Date.now() / 1000;\r\n  },\r\n\r\n  // CreateVideoElements: function() {\r\n  //   var elements = document.querySelectorAll('.jsmpeg');\r\n  //   for (var i = 0; i < elements.length; i++) {\r\n  //     new JSMpeg.VideoElement(elements[i]);\r\n  //   }\r\n  // },\r\n\r\n  Fill: function (array, value) {\r\n    if (array.fill) {\r\n      array.fill(value);\r\n    }\r\n    else {\r\n      for (let i = 0; i < array.length; i++) {\r\n        array[i] = value;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport default JSMpeg;"]}